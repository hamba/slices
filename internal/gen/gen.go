package main

import (
	"bytes"
	"go/format"
	"log"
	"os"
	"text/template"
)

var tmpl = `package slices

// Code generated by 'gen.go'. DO NOT EDIT.

import "unsafe"

// Contains
{{- range $i, $type := .contains}}
func {{ $type }}Contains(sptr, vptr unsafe.Pointer) bool {
	v := *(*{{ $type }})(vptr)
	for _, vv := range *(*[]{{ $type }})(sptr) {
		if vv == v {
			return true
		}
	}
	return false
}
{{end -}}

// LesserOf
{{- range $i, $type := .lesserOf}}
func {{ $type }}Lesser(ptr unsafe.Pointer) func(i, j int) bool {
	return func(i, j int) bool {
		v := *(*[]{{ $type }})(ptr)
		return v[i] < v[j]
	}
}
{{end -}}

// GreaterOf
{{- range $i, $type := .greaterOf}}
func {{ $type }}Greater(ptr unsafe.Pointer) func(i, j int) bool {
	return func(i, j int) bool {
		v := *(*[]{{ $type }})(ptr)
		return v[i] > v[j]
	}
}
{{end -}}

// Intersect
{{- range $i, $type := .intersect}}
func {{ $type }}Intersect(sptr, optr unsafe.Pointer) interface{} {
	slice := make([]{{ $type }}, len(*(*[]{{ $type }})(sptr)))
	copy(slice, *(*[]{{ $type }})(sptr))
	for i := 0; i < len(slice); i++ {
		found := false
		for _, v := range *(*[]{{ $type }})(optr) {
			if v == slice[i] {
				found = true
				break
			}
		}
		if !found {
			slice = append(slice[:i], slice[i+1:]...)
			i--
		}
	}
	return slice
}
{{end -}}

// Except
{{- range $i, $type := .except}}
func {{ $type }}Except(sptr, optr unsafe.Pointer) interface{} {
	s := make([]{{ $type }}, len(*(*[]{{ $type }})(sptr)))
	copy(s, *(*[]{{ $type }})(sptr))
	for i := 0; i < len(s); i++ {
		for _, v := range  *(*[]{{ $type }})(optr) {
			if v == s[i] {
				s = append(s[:i], s[i+1:]...)
				i--
				break
			}
		}
	}
	return s
}
{{end -}}

`

func main() {
	parse, err := template.New("gen").Parse(tmpl)
	if err != nil {
		log.Fatal(err)
	}

	ops := map[string][]string{
		"contains":  {"bool", "string", "int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64", "float32", "float64"},
		"lesserOf":  {"string", "int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64", "float32", "float64"},
		"greaterOf": {"string", "int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64", "float32", "float64"},
		"intersect": {"string", "int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64", "float32", "float64"},
		"except":    {"string", "int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64", "float32", "float64"},
	}

	b := &bytes.Buffer{}
	if err = parse.Execute(b, ops); err != nil {
		log.Fatal(err)
	}

	source, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	if err = os.WriteFile("ops.gen.go", source, 0600); err != nil {
		log.Fatal(err)
	}
}
